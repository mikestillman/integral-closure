newPackage(
        "TraceForm",
        Version => "0.1", 
        Date => "25 Oct 2009",
        Authors => {
	     {Name => "Charley Crissman", 
		  Email => "charleyc@math.berkeley.edu", 
		  HomePage => "http://math.berkeley.edu/~charleyc/"},
	     {Name => "Mike Stillman", 
              	  Email => "mike@math.cornell.edu", 
                  HomePage => "http://www.math.cornell.edu/~mike"}},
        Headline => "trace form and multiplication maps for a Noether normalization",
        DebuggingMode => true
        )

export {
     "getBasis",
     "multiplication",
     "traceForm",
     "traceFormAll",
     "noetherPosition",
     "noetherField",  -- the names of these 
     "noetherRing"   -- two functions must change!
     }

debug Core
isField EngineRing := R -> (R.?isField and R.isField) or rawIsField raw R

noetherPosition = method()
noetherPosition List := (xv) -> (
     -- R should be a quotient of a polynomial ring,
     -- xv a list of variables, algebraically independent in R
     -- result: a ring over the sub-poly ring or subfield generated by
     --  the variables xv.
     if #xv === 0 then error "expected non-empty list of variables";
     R := ring xv#0;
     if any(xv, x -> ring x =!= R) then error "expected variables all in the same ring";
     if any(xv, x -> index x === null) then error "expected variables";
     I := ideal R;
     Rambient := ring I;
     xindices := for x in xv list index x;
     otherindices := sort toList (set toList(0..numgens R - 1) - set xindices);
     kk := coefficientRing R;
     A := kk [xv, Degrees => (degrees R)_xindices, Join=>false];
     KA := frac A;
     SProd := kk(monoid[(gens R)_otherindices, xv, MonomialOrder => {#otherindices, #xv}, Degrees=>join((degrees R)_otherindices, (degrees R)_xindices)]);
     S := A[(gens R)_otherindices, Degrees => (degrees R)_otherindices, Join=>false];
     SK := KA[(gens R)_otherindices, Degrees => (degrees R)_otherindices, Join=>false];
     phi := map(S,Rambient, sub(vars Rambient, S));
     phiK := map(SK,Rambient, sub(vars Rambient, SK));
     J := trim phi I;
     JK := trim phiK I;
     B := S/J;
     BK := SK/JK;
     BtoBK := map(BK,B,generators BK);
     inverse B := f -> 1_BK // BtoBK f;
     B / A := (f,g) -> (1/g) * BtoBK f;
     B / B := (f,g) -> (BtoBK f) * (inverse g);
     BK / A := (f,g) -> (1/g) * f;
     mapBtofracSProd := map(frac SProd, B);
     mapBKtofracSProd := map(frac SProd, BK);
     SProdToB := map(B, SProd);
     SProdToS := map(S, SProd);
     numerator B := (f) -> SProdToB (numerator mapBtofracSProd f);
     numerator BK := (f) -> SProdToB (numerator mapBKtofracSProd f);
     denominator B := (f) -> lift(SProdToB denominator mapBtofracSProd f, A);
     denominator BK := (f) -> lift(SProdToB denominator mapBKtofracSProd f, A);
     net BK := (f) -> (
         n := numerator f; 
         d := denominator f;
	     resultDenom := if d == 1 then 1 else factor d;
	     (hold n) / resultDenom
         );
     factor B := opts -> (f) -> (hold factor (numerator mapBtofracSProd f))/(factor denominator f);
     factor BK := opts -> (f) -> (hold factor (numerator mapBKtofracSProd f))/(factor denominator f);
     B#"NoetherField" = BK;
     BK#"NoetherRing" = B;
     B.frac = BK; -- TODO: also add in promotion/lift functions?
     BK.frac = BK; -- I wonder if we need to set L to be a field too?  If so, that miight be a problem...
     BK.isField = true;
     setTraces BK;
     B)

noetherField = method()
noetherField Ring := (R) -> (
     if R#?"NoetherField" 
     then R#"NoetherField" 
     else if R#?"NoetherRing"
       then R
       else error "no ring"
     )

noetherRing = method()
noetherRing Ring := (R) -> (
     if R#?"NoetherRing" 
     then R#"NoetherRing" 
     else if R#?"NoetherField"
       then R
       else error "no ring"
     )
     
basisOfRing= method()
basisOfRing Ring := (R) -> (
     if not R#?"TraceFormInfo" then R#"TraceFormInfo" = (
     	  -- assumption: R is finite over the coefficient ring
     	  -- returns a matrix over R whose entries are generators
     	  -- of R over the coeff ring
     	  LT := leadTerm ideal R;
     	  K := ultimate(coefficientRing, R);
     	  R1 := K (monoid R);
     	  J := ideal sub(LT,R1);
     	  B := sub(cover basis(comodule J), R);
	  -- now present this in two ways:
	  -- (1) as a list of monomials in R (or, as a matrix?)
	  -- (2) as a hash table, m => i, giving the index of each monomial.
	  B = sort B;
	  L := flatten entries B;
	  H := hashTable for i from 0 to #L-1 list L#i => i;
	  Rambient := ambient R;
     	  S := new MutableHashTable from apply(L, s -> {lift(s,Rambient),s});
	  new MutableHashTable from {
	       "basis" => B,
	       "inverse basis" => H,
	       "monomials" => S
	       }
     	  );
     R#"TraceFormInfo"
     )

getBasis = method()
getBasis Ring := (R) -> first entries (basisOfRing R)#"basis"

getBasisMatrix = method()
getBasisMatrix Ring := (R) -> (basisOfRing R)#"basis"

multiplication = method()
multiplication RingElement := (m) -> (
     R := ring m;
     S := getBasisMatrix R;
     (mn, cf) := coefficients(m * S, Monomials => S);
     lift(cf,coefficientRing R)
     )

setTraces = (R) -> (
     -- R should be a Noether field
     B := getBasis R;
     traces := for b in B list (
	  m := multiplication b;
	  --numerator lift(trace m, coefficientRing R)
	  t := lift(trace m, coefficientRing R);
	  tdenom := lift(denominator t, coefficientRing ring t);
	  1/tdenom * numerator t
	  );
     R#"Traces" = matrix{traces};
     traces
     )

tr = method()
tr RingElement := (f) -> (
     -- R = ring f should be a noetherRing or noetherField
     -- result is in the coefficient ring of R.
     R := ring f;
     RK := noetherField R;
     f = sub(f,RK);
     M := last coefficients(f, Monomials => getBasisMatrix RK);
     g := (RK#"Traces" * M)_(0,0);
     g = lift(g, coefficientRing RK);
     --stopgap for lifts from frac QQ[x] to QQ[x] not working 5-26-11
     --when works, change below to return lift(g, coefficientRing R)
     gdenom := denominator g;
     if gdenom == 1 then numerator g else (
	  gdenom = lift(gdenom, coefficientRing ring gdenom);
	  1/gdenom * numerator g
	  )
     )

traceForm = method()
traceForm Ring := (R) -> (
     if not R#?"TraceForm" then R#"TraceForm" = (
     	  S := getBasis R;
     	  K := coefficientRing R;
     	  M := mutableMatrix(K, #S, #S);
     	  for i from 0 to #S-1 do
       	  for j from i to #S-1 do (
	       f := tr(S#i * S#j);
	       M_(i,j) = M_(j,i) = f;
	       );
     	  matrix M
	  );
     R#"TraceForm"
     )
     
traceFormAll = method()
traceFormAll Ring := (R) -> (
     S := getBasis R;
     (S, traceForm R, S/multiplication)
     )

--------------------------------------------------------------------------------
-- Not used yet.  Maybe this can help improve speed of computation of traces? --
--------------------------------------------------------------------------------
-- the following two are not currently used.  Remove them, and the
-- creation of the corresponding hash tables?  (MES: 5/25/2011)
getMonomials = (R) -> (basisOfRing R)#"monomials"
getBasisIndices = (R) -> (basisOfRing R)#"inverse basis"

standardMonomials = (M) -> (
     -- M:MonomialIdeal
     -- returns: list of monomials not in M
     -- assumption: M is zero dimensional
     L := flatten entries cover basis comodule M;
     (L, hashTable for i from 0 to #L-1 list L#i => i)
     )

borderMonomials = (M,S) -> (
     -- M:MonomialIdeal
     -- S:HashTable s => i
     -- return list of (m,vs)
     --   m is a border monomial (i.e. a monomial of the form x_i * n, n standard
     --      and m is not standard
     --      and vs is a list of indices i s.t. m//x_i is standard
     -- or maybe it should return a hash table m => vs.
     xs := gens ring M; -- all the variables
     H := new MutableHashTable;
     for xi in xs do for s in keys S do (
	  m := xi * s;
	  if m % M == 0 then (
	       if not H#?m 
	         then H#m = {xi}
		 else H#m = append(H#m, xi);
	       );
	  );
     new HashTable from H
     )

variablesAsMatrices = (M,S,H) -> (
     -- M:MonomialIdeal
     -- S:Hashtable of std monomials (m => index)
     -- H:HashTable, as returned by borderMonomials
     R := ring M;
     Ms := for i from 0 to numgens R - 1 list mutableMatrix(R,#S,#S);
     P := {};
     scan(pairs H, (m,vs) -> (
	       for x in vs do P = append(P, (index x, S#(m // x), m))
	       ));
     P
     )

reduceMonomial = (B, m) -> (
     -- m should be s monomial in the ambient poly ring of R
     -- B should be R#"Traceform reduced"
     if not B#?m then B#m = (
	  s := support m;
	  x := first s;
	  m1 := m//x;
	  x * reduceMonomial(B,m1)
	  );
     B#m
     )
---------------------------------------------------------------
-- End of not used section ------------------------------------
---------------------------------------------------------------
beginDocumentation()

multidoc ///
Node
  Key
    TraceForm
  Headline
    trace form of a Noether normalization
  Description
    Text
      Routines for finding multiplication matrices and the trace form.
      We assume that the ring R is of the form $A[x_1\ldots x_n]/I$, and is finite over $A$.
    
      This package provides routines for finding the multiplication map associated to an element
      of $R$, and for finding the trace form.
  Caveat
  
Node
  Key
    noetherPosition
    (noetherPosition,List)
  Headline
    create a tower of two rings which is a finite extension
  Usage
    S = noetherPosition xv
  Inputs
    xv:List
      of variables in the same ring R, where R is a quotient
      of a polynomial ring
  Outputs
    S:Ring
      isomorphic to R, but whose coefficient ring is kk[xv], or kk(xv)
  Description
    Text
      This is a convenience routine, which should perhaps be placed elsewhere.
      
      Let's try this out on the rational quartic curve:
    Example
      S = QQ[a..d]
      R = S/monomialCurveIdeal(S,{1,3,4})
      A = noetherPosition{a,d}
      getBasis A
    Text
      If the OverField optional argument is true, then the base ring is a field:
    Example
      noetherField A
      L = oo
      getBasis L
      coefficientRing A
      coefficientRing L
  Caveat
    Make sure the variables are in the ring that you want.
  SeeAlso
    getBasis
    noetherField
    noetherRing
Node
  Key
    getBasis
    (getBasis,Ring)
  Headline
    monomial basis for a finite extension of rings
  Usage
    getBasis R
  Inputs
    R:Ring
      a quotient of a polynomial ring, which is finite over its coefficient ring $A$
  Outputs
    :List
      consisting of monomials in $R$, which generate $R$ as an $A$-module
  Description
    Text
      Note that the result is not necessarily a 'basis', just a generating set.
    Example
      S = QQ[a..d];
      R = S/monomialCurveIdeal(S,{1,3,4});
      T = noetherPosition{a,d};
      describe T
      getBasis T
    Text
      The basis information, and other information about the basis, is stashed in the ring, but you
      should use {\tt getBasis} to access this information.
    Example
      peek T#"TraceFormInfo"
  Caveat
    Currently, this does not work if the coefficient ring is not over a field, e.g. if the ring is over ZZ.
    This will be fixed soon, hopefully!  It has also not yet been tested in the case that $A$ is a tower of
    rings.
  SeeAlso
    noetherPosition
Node
  Key
    multiplication
    (multiplication,RingElement)
  Headline
    matrices corresponding to multiplication by ring elements
  Usage
    multiplication f
  Inputs
    f:RingElement
      in a ring $R$ in Noether position: 
      $R = A[x_1 \ldots x_n]/I$, which is finite over $A$.
  Outputs
    :Matrix
      over $A$, corresponding to the $A$-module 
      map given by multiplication by $f$ (or by the ring elements in the list $f$).
  Description
    Text
    Example
      S = QQ[a..d];
      R = S/monomialCurveIdeal(S,{1,3,4});
      T = noetherPosition{a,d};
      describe T
      getBasis T
      multiplication b
    Example
      L = noetherField T
      describe L
      getBasis L
      multiplication b
      multiplication \ {b,c,b^2}
  Caveat
  SeeAlso
    getBasis
    noetherPosition
    traceForm
Node
  Key
    traceForm
    (traceForm, Ring)
  Headline
    the trace form of a ring in Noether normal position
  Usage
    M = traceForm R
  Inputs
    R:Ring
      in Noether position: $R = A[x_1, \ldots, x_n]/I$, which is finite over
      the coefficient ring $A$.
  Outputs
    M:Matrix
      a square matrix over $A$, whose $(i,j)$ entry is $trace(m_i m_j)$, where
      either the $m_i$ form a generating set of $R$ over $A$, or they are the
      given elements in $L$
  Description
    Text
      
    Example
      S = QQ[a..d];
      R = S/monomialCurveIdeal(S,{1,3,4});
      T = noetherPosition{a,d}
      describe T
      getBasis T
      multiplication (c^4)
      traceForm T
    Text
      The trace form of the field extension $QQ(a,d) \subset L$:
    Example
      noetherField T
      L = noetherField T
      getBasis L
      traceForm L
      factor det traceForm L
  SeeAlso
    multiplication
    getBasis
    noetherPosition
    noetherField
///

TEST ///
  S = ZZ/32003[a..d]
  I = monomialCurveIdeal(S,{1,3,4})
  R = S/I

  B1 = noetherPosition({a,d})
  describe B1
  use B1
  assert(getBasis B1 === {1_B1, c, b, c^2, b^2})
  assert(multiplication b - 
     matrix"0, ad, 0, 0, 0; 
            0, 0, 0, ad, a2; 
	    1, 0, 0, 0, 0; 
	    0, 0, 0, 0, 0; 
	    0, 0, 1, 0, 0" 
	== 0)

  -- now the extension field
  B2 = noetherField B1
  multiplication \ {1_B2, b, c, b^2, c^2}
  assert(multiplication b - 
     matrix {{0, a*d, 0, 0}, 
	  {0, 0, 0, a*d}, 
	  {1, 0, 0, 0}, 
	  {0, 0, (a)/(d), 0}}
     == 0)

  assert(0 == traceForm B1 - 
     matrix {{4, 0, 0, 0, 0}, 
	  {0, 0, 4*a*d, 0, 0}, 
	  {0, 4*a*d, 0, 0, 0}, 
	  {0, 0, 0, 4*a*d^3, 4*a^2*d^2}, 
	  {0, 0, 0, 4*a^2*d^2, 4*a^3*d}})
  assert(0 == traceForm B2 - 
     matrix {{4, 0, 0, 0}, 
	  {0, 0, 4*a*d, 0}, 
	  {0, 4*a*d, 0, 0}, 
	  {0, 0, 0, 4*a*d^3}})

  kx = coefficientRing B1
  assert(ring traceForm B1 === kx)
  assert(ring traceForm B2 === frac kx)
///

TEST ///
  --boehm4
  --S = frac (ZZ/32003[v,z])[u]
  S = ZZ/32003[u,v,z]
  F = 25*u^8+184*u^7*v+518*u^6*v^2+720*u^5*v^3+
     576*u^4*v^4+282*u^3*v^5+84*u^2*v^6+14*u*v^7+
     v^8+244*u^7*z+1326*u^6*v*z+2646*u^5*v^2*z+2706*u^4*v^3*z+
     1590*u^3*v^4*z+546*u^2*v^5*z+102*u*v^6*z+8*v^7*z+
     854*u^6*z^2+3252*u^5*v*z^2+4770*u^4*v^2*z^2+
     3582*u^3*v^3*z^2+1476*u^2*v^4*z^2+318*u*v^5*z^2+
     28*v^6*z^2+1338*u^5*z^3+3740*u^4*v*z^3+4030*u^3*v^2*z^3+
     2124*u^2*v^3*z^3+550*u*v^4*z^3+56*v^5*z^3+1101*u^4*z^4+
     2264*u^3*v*z^4+1716*u^2*v^2*z^4+570*u*v^3*z^4+
     70*v^4*z^4+508*u^3*z^5+738*u^2*v*z^5+354*u*v^2*z^5+
     56*v^3*z^5+132*u^2*z^6+122*u*v*z^6+28*v^2*z^6+
     18*u*z^7+8*v*z^7+z^8
  R1 = S/F
  R = noetherPosition{v,z}
  time traceForm noetherField R
  getBasis R

  time traceForm R;
  time traceForm noetherField R;

  use R
  M = multiplication u
///

TEST ///
  --vanHoeij2
  S = QQ[x,y]
  ideal"y20+y13x+x4y5+x3(x+1)2"
  R = S/oo

  use R
  R1 = noetherPosition( {x})
  describe R1
  getBasis R1
  time traceForm R1;
  time traceForm noetherField R1;

  use R
  R2 = noetherPosition {y}
  describe R2
  getBasis R2
  time traceForm R2;
  time traceForm noetherField R2;
///

TEST ///
  --GLS7-char32003
  kk = ZZ/32003 -- from Greuel-Laplagne-Seelisch arXiv:0904.3561v1
  S = kk[x,y,z,w,t]
  I = ideal"x2+zw,
    y3+xwt,
    xw3+z3t+ywt2,
    y2w4-xy2z2t-w3t3"
  I = sub(I, {z => z+w, t => t+w})
  R = S/I

  R1 = noetherPosition({z,t})
  getBasis R1
  (noetherField R1)#"Traces"
  B = getBasis noetherField R1
  time traceForm R1;
  time traceForm noetherField R1;
///

TEST ///
  --boehm15
  kk = ZZ/32003
  kk = QQ
  S = kk[u,v,z]
  F = -2*u*v^4*z^4+u^4*v^5+12*u^4*v^3*z^2+12*u^2*v^4*z^3-u^3*v*z^5+11*u^3*v^2*z^4-21*u^3*v^3*z^3-4*u^4*v*z^4+2*u^4*v^2*z^3-6*u^4*v^4*z+u^5*z^4-3*u^5*v^2*z^2+u^5*v^3*z-3*u*v^5*z^3-2*u^2*v^3*z^4+u^3*v^4*z^2+v^5*z^4
  G = sub(F, {v => u+v})
  R1 = S/G
  R = noetherPosition {v,z}
  describe R
  time traceForm R
  time traceForm noetherField R
///

///
Node
  Key
  Headline
  Usage
  Inputs
  Outputs
  Consequences
  Description
    Text
    Example
  Caveat
  SeeAlso
///

end--

restart
loadPackage "TraceForm"
uninstallPackage "TraceForm"
installPackage "TraceForm"
check TraceForm -- one error currently.

--------------------------------
-- Testing the creation of border basis
restart
debug loadPackage "TraceForm"
R = QQ[a..f]
I = monomialIdeal(a,b,c,d^2,d*e^2,e^3,f^2)
S = standardMonomials I
time H = borderMonomials(I,S);
variablesAsMatrices(I,S,H)
-- now compute the matrices of the variables

I = monomialIdeal(a^3, b^3, c^3, d^3, e^3, f^3, c*d*e*f)

--examples testing lift
restart
loadPackage "TraceForm"
S = QQ[x,y]
F = 2*y^2 - y*x + 1
R = S/F
A = noetherPosition {x}
getBasis A
traceForm A


TEST ///
-- test of noetherPosition and its use
-*
  restart
  loadPackage "TraceForm"
*-
  S = QQ[x,y]
  F = 2*y^2 - y*x + 1
  R = S/F
  A = noetherPosition {x}

  F = (x+y)/(x-1)
  use A;
  assert(numerator F == x+y)
  assert(ring numerator F === A)
  assert(denominator F == x-1)
  assert(ring denominator F === coefficientRing A)
  assert((numerator F) / (denominator F) == F)

  AK = noetherField A
  G = (x+y)/(x-1)
  assert(F == G)
  
  -- want: numerator, denominator to work.  Where will they put you?
  -- numerator should be in the ring A, denominator in coefficientRing A
  coefficientRing A

  F
  leadTerm F
  leadCoefficient F

  factor F
///

TEST ///
-*
  restart
  loadPackage "TraceForm"
*-
  S = QQ[a,b,c,x,y,z]
  R = S/(x^2-a, y^2-x, z^2-y)
  A = noetherPosition {a,b,c}
  F = (x+y+z)/(a+1)
  AK = ring F
  numerator F
  denominator F
  factor F
  F^4
  M = matrix{{F^4, F+1}}
  compactMatrixForm = false -- doesn't work well here!
  netList applyTable(entries M, net)
  G = F^4 + F^2 + 1
  factor G
///

TEST ///
-*
  restart
  loadPackage "TraceForm"
*-
  S = QQ[a,b]
  R = S/(b^2-b-a)
  A = noetherPosition{a}
  b^4
  -- we want to invert elements in this field (if it is a field).
  F = b^4
  B = sub(matrix{getBasis A}, noetherField A)
  M = (multiplication F) ** noetherField A
  M^-1
  I = flatten entries oo_{0} -- 
  G = sum for i from 0 to #I-1 list (I_i * M_(i,0))
  G * sub(F, ring G)
///

TEST ///
-*
  restart
  needsPackage "NoetherNormalization"
  loadPackage "TraceForm"
*-
  S = ZZ/101[a..d]
  I = monomialCurveIdeal(S, {1,3,4})
  (f1, I1, basevars) = noetherNormalization I
  assert(f1 I == I1)
  basevars == {d,c}
///

TEST ///
-*
  restart
  loadPackage "TraceForm"
*-
  R = ZZ/101[x,y]/(y^3-x*y-x^2)
  B = noetherPosition {x}
  describe B
  L1 = frac R
  L = noetherField B
  A = coefficientRing B
  K = coefficientRing L
  assert(K === frac A)
  assert(L === frac B)

  ring x === K
  ring y === L
  use B
  matrix{{1 / y}}
  use A
  promote((x+y),L) * (1/(x+y)) -- no function for B * BK !!
  -- no promote/lift availabble from B to BK?
  -- want to be able to add A + BK into L?
  1/(3*y^2+x)
  --fraction(1_B, y_B)
  1_L // y_L  


  y^3/(x+1)
  1/y
  
  use L
  1_L / y -- doesn't work yet...
///
