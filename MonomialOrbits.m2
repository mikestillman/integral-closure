
patterns = (S,deg,num) -> (
    n := numgens S;
    P := partitions(deg, n)/toList/sort;
    unique\\sort\toList\splice\(toList((set P)^**num))
)

pattern = m -> sort exponents m

///
netList patterns(S,3,2)
m = a^2*b
pattern m
///

monomialIdealsByPattern = method()
monomialIdealsByPattern (Ring, List) := List => (S,L) ->(
    --L should be a list of lists of non-negative integers, each of length numgens S, in rsort order.
    --Returns a list of monomial ideals in S generated by monomials whose exponent lists match L.
    if numgens S<#L then error"list is too long";
    M := orbit trim ideal apply(L, p-> product(#p, i-> S_i^(p_i)))
)


orbitRepresentatives = method(Options => {Strict => true})
orbitRepresentatives (Ring, List) := List => o -> (S,L) ->(
    --L should be a list of lists of non-negative integers, each of length numgens S, in rsort order.
    --Returns a list of orbit representatives of the 
    -- monomial ideals in S generated by monomials whose exponent lists match L.
    
    Lu := unique L;
    LL := apply(#Lu,i -> #select(L, ell -> ell == Lu_i));
    M := apply(#Lu, i -> monomialIdealsByPattern(S,{Lu_i}));
    MM = for i from 1 to #Lu -1 list ideal\subsets(M_i,LL_i);
    M_0)
-*
    I = {M_0_0};
    for j from 1 to #Lu-1 do(
    I = select(sum\ (I**M_j), J -> numgens trim J == j+1));
    I)
*-
    
///
restart
load "MonomialOrbits.m2"
S = ZZ/32003[x,y,z]
L = {{2,2,2}, {1,0,0}}
orbitRepresentatives(S,L)

L = {{3}}
monomialIdealsByPattern(S,{{3}})
L = {{3,0,0},{3,0,0}, {4,1,0}}



L = {{2,2,2}, {1,2,3}}
L = {{1,0,0},{2,0,0}}
P = patterns(S,3,2)

netList apply(P, p->orbitRepresentatives(S,p))


monomialIdealsByPattern (S,L)
I = ideal"x2y"
orbit I

///

orbit = I -> ( --orbit of a monomial ideal)
    S := ring I;
    n := numgens S;
    if not S#?"permutationMaps" then(
    maps  := apply(permutations n, q -> map(S,S,(vars S)_q));
    S#"permutationMaps" = maps
    );
    unique apply(S#"permutationMaps",f -> ideal rsort gens f I)
    )

end--
restart
load "MonomialOrbits.m2"

I = ideal"abc,c3"
I = ideal"ab,ac"

    
use S    


netList patterns(S,3,3)

unique\\sort\((partitions(deg, numgens S))/toList/sort ** (toList partitions(deg, numgens S))/toList/sort)

vars T
basis (2,T)
